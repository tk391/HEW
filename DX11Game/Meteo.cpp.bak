//=============================================================================
//隕石[Meteo.cpp]
//12/11 齋藤成希
//=============================================================================
#include "Meteo.h"
#include "AssimpModel.h"
#include "debugproc.h"
#include "collision.h"
#include <vector>
#include"input.h"
#include "Game.h"


//マクロ
#define MODEL_DEBLY			"data/model/meteorite.fbx"

//モデルの大きさは使用するモデルによって動かして確認しなければならない
#define DEBLY_SIZE		(16.375f/5.0f)
#define OUTSIDE_AREA_X	(-750.0f)			//◆仮　エリア外座標
#define MOVE_SPEED		(0.6f)				//動くスピード


//デブリの情報を持つ構造体
struct TMeteo {
	XMFLOAT3 m_Pos;				// 位置
	XMFLOAT3 m_Scl;				// スケール
	float	 m_fAngle;			// ベクトルを求める用の角度
	int		m_RotDir;
	XMFLOAT3 m_fRot;			// 角度
	XMFLOAT3 m_DefaultPos;		// 初期位置

	XMFLOAT4X4	m_mtxWorld;	// ワールドマトリックス
};


//クラス
Player* Meteo_Player;

//グローバル変数
static CAssimpModel	g_model;				// モデル
static int g_nMeteoCount;					// ステージごとの隕石数

static std::vector<TMeteo> meteoArray;		// 隕石を管理する動的配列

#if _DEBUG
static int g_count;		//計測用
#endif // _DEBUG


//=============================================================================
//初期化
//=============================================================================
HRESULT Meteo::Init(int StageNum) {
	HRESULT hr = S_OK;
	ID3D11Device* pDevice = GetDevice();
	ID3D11DeviceContext* pDeviceContext = GetDeviceContext();

	// モデルデータの読み込み
	if (!g_model.Load(pDevice, pDeviceContext, MODEL_DEBLY)) {
		MessageBoxA(GetMainWnd(), "モデルデータ読み込みエラー", "InitEnemy", MB_OK);
		return E_FAIL;
	}
	Create(StageNum);

	std::vector<TMeteo>::iterator it;
	it = meteoArray.begin();	//イテレーターを動的配列の最初に持ってくる
	while (it != meteoArray.end()) {
		it->m_DefaultPos = it->m_Pos; //初期位置を保存する
		it++;
	}
#if _DEBUG
	g_count = 1;
#endif

	Meteo_Player = GetPlayer();
	return hr;
}

//=============================================================================
//終了
//=============================================================================
void Meteo::Uninit(void) {
	// モデルの解放
	g_model.Release();

	//動的配列を消去
	meteoArray.clear();
}

//=============================================================================
//更新
//=============================================================================
void Meteo::Update(void) {
	XMMATRIX mtxWorld, mtxRot, mtxScl, mtxPos;


#if _DEBUG
	if (GetKeyTrigger(VK_HOME)) {
		g_count++;
	}
	if (GetKeyTrigger(VK_END)) {
		g_count--;
	}
	if (g_count < 0) {
		g_count = meteoArray.size();
	}
	if (g_count >= meteoArray.size()) {
		g_count = 1;
	}
	if (GetKeyPress(VK_D)) {
		meteoArray[g_count].m_Pos.x += 2.0f;
	}
	if (GetKeyPress(VK_A)) {
		meteoArray[g_count].m_Pos.x -= 2.0f;
	}
	if (GetKeyPress(VK_W)) {
		meteoArray[g_count].m_Pos.y += 2.0f;
	}
	if (GetKeyPress(VK_S)) {
		meteoArray[g_count].m_Pos.y -= 2.0f;
	}

	std::vector<TMeteo>::iterator it;
	it = meteoArray.begin();	//イテレーターを動的配列の最初に持ってくる
	PrintDebugProc("meteoArray[%d].m_Pos={%.2f,%.2f}\n", g_count, it->m_Pos.x, it->m_Pos.y);
	PrintDebugProc("meteoArray[%d].m_Scl={%.2f,%.2f}\n", g_count, it->m_Scl.x, it->m_Scl.y);
#endif // _DEBUG 

	//イテレーター
#if !_DEBUG
	std::vector<TMeteo>::iterator it;
#endif
	it = meteoArray.begin();	//イテレーターを動的配列の最初に持ってくる
	while (it != meteoArray.end()) {
		//回転
		switch (it->m_RotDir)
		{
		case 0:
			it->m_fRot.x = it->m_fRot.x + 0.3f;
			break;
		case 1:
			it->m_fRot.y = it->m_fRot.y + 0.3f;
			break;
		case 2:
			it->m_fRot.z = it->m_fRot.z + 0.3f;
			break;
		}
		//位置にベクトルを加算
		it->m_Pos.x += SinDeg(it->m_fAngle)*MOVE_SPEED;
		it->m_Pos.y += CosDeg(it->m_fAngle)*MOVE_SPEED;

		//◆仮実装　エリア外に行った隕石位置を修正
		if (it->m_Pos.x < OUTSIDE_AREA_X) //隕石がエリアの一定外に行ったら
		{
			//隕石の座標をデフォルト位置に修正
			it->m_Pos = it->m_DefaultPos;
		}

		if (it->m_Pos.y < OUTSIDE_AREA_X)
		{
			it->m_Pos = it->m_DefaultPos;
		}
		// ワールドマトリックスの初期化
		mtxWorld = XMMatrixIdentity();

		//デブリ回転の反映
		mtxRot = XMMatrixRotationRollPitchYaw(XMConvertToRadians(it->m_fRot.x), XMConvertToRadians(it->m_fRot.y), XMConvertToRadians(it->m_fRot.z));
		mtxWorld = XMMatrixMultiply(mtxWorld, mtxRot);

		//スケールを反映
		mtxScl = XMMatrixScaling(it->m_Scl.x, it->m_Scl.y, it->m_Scl.z);
		mtxWorld = XMMatrixMultiply(mtxWorld, mtxScl);

		// 位置を反映
		mtxPos = XMMatrixTranslation(it->m_Pos.x, it->m_Pos.y, it->m_Pos.z);
		mtxWorld = XMMatrixMultiply(mtxWorld, mtxPos);

		// ワールドマトリックス設定
		XMStoreFloat4x4(&it->m_mtxWorld, mtxWorld);

		it++;
	}

}

//=============================================================================
//描画
//=============================================================================
void Meteo::Draw(void) {
	ID3D11DeviceContext* pDC = GetDeviceContext();

	//イテレーター
	std::vector<TMeteo>::iterator it;
	it = meteoArray.begin();

	// 不透明部分を描画
	while (it != meteoArray.end()) {
		g_model.Draw(pDC, it->m_mtxWorld, eOpacityOnly);
		it++;
	}

	it = meteoArray.begin();
	// 半透明部分を描画
	while (it != meteoArray.end()) {
		SetBlendState(BS_ALPHABLEND);	// アルファブレンド有効
		SetZWrite(false);				// Zバッファ更新しない
		g_model.Draw(pDC, it->m_mtxWorld, eTransparentOnly);
		SetZWrite(true);				// Zバッファ更新する
		SetBlendState(BS_NONE);			// アルファブレンド無効

		it++;
	}
}

//=============================================================================
//衝突判定
//=============================================================================
int Meteo::Collision(XMFLOAT3 pos, XMFLOAT3 size) {
	//イテレーター
	std::vector<TMeteo>::iterator it;
	it = meteoArray.begin();
	int count = 0;
	while (it != meteoArray.end()) {
		XMFLOAT3 m_Size = g_model.GetBBox();
		m_Size = XMFLOAT3(m_Size.x*it->m_Scl.x * 0.3, m_Size.y*it->m_Scl.y * 0.3, m_Size.z*it->m_Scl.z * 0.3);
		int collisilon = CollisionSphere(it->m_Pos, m_Size.x, pos, size.y);
		//一つずつ見ていって、あたってなかったら次の番号へ
		if (collisilon == false) {
			it++;
			count++;
			continue;
		}
		//あたってたらそのモデルの番号を返す
		return count;
		//return -1;
	}
	//何もあたっていなかったら-1
	return -1;
}

//=============================================================================
//プレイヤーと衝突したデブリの位置を取得
//=============================================================================
XMFLOAT3 Meteo::GetPos(int num) {
	return meteoArray[num].m_Pos;
}

//=============================================================================
//プレイヤーと衝突したデブリの大きさを取得
//=============================================================================
XMFLOAT3 Meteo::GetSize(int num) {
	XMFLOAT3 size = g_model.GetBBox();
	size = XMFLOAT3(meteoArray[num].m_Scl.x*size.x, meteoArray[num].m_Scl.y*size.x, meteoArray[num].m_Scl.z*size.x);

//	size = XMFLOAT3(meteoArray[num].m_Scl.x*0.3f, 
//		meteoArray[num].m_Scl.y*0.3f,
//		meteoArray[num].m_Scl.z*0.3f);
	return size;
}

//=============================================================================
//プレイヤーと衝突したデブリのうごくベクトルを取得
//=============================================================================
//XMFLOAT3 Meteo::GetVector(int num) {
//	return meteoArray[num].;
//}

//=============================================================================
//プレイヤーと衝突したデブリの角度を取得
//=============================================================================
float Meteo::GetAngle(int num) {
	return meteoArray[num].m_fAngle;
}

//=============================================================================
//プレイヤーと衝突したデブリの移動量を取得
//=============================================================================
//XMFLOAT3 Meteo::GetMoveSpeed(int num) {
//	return meteoArray[num].g_fMoveSpeed;
//}

//=============================================================================
//情報のセット
//=============================================================================
void Meteo::Create(int StageNum) {
	switch (StageNum) {
	case 1:
		//ステージ1で必要な隕石を生成していく
		//                               位置　　　　　　　　　　　　　　大きさ　　　　　角度　　
		meteoArray.push_back({ XMFLOAT3(-12000.0f,80.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),200.0f });
		meteoArray.push_back({ XMFLOAT3(-12000.0f,85.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),180.0f });
		meteoArray.push_back({ XMFLOAT3(-12000.0f,85.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),225.0f });
		meteoArray.push_back({ XMFLOAT3(-12000.0f,-225.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),255.0f });
		break;
	case 2:
		meteoArray.push_back({ XMFLOAT3(-12000.0f,80.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),200.0f });
		meteoArray.push_back({ XMFLOAT3(-12000.0f,80.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),200.0f });
		break;
	case 3:
		meteoArray.push_back({ XMFLOAT3(-480.0f,-3.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),135.0f });
		meteoArray.push_back({ XMFLOAT3(-210.0f,170.0f,0.0f),XMFLOAT3(33.5f,33.5f,33.5f),150.0f });
		meteoArray.push_back({ XMFLOAT3(339.0f,93.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),290.0f });
		break;
	case 4:
		meteoArray.push_back({ XMFLOAT3(-95.0f,185.0f,0.0f),XMFLOAT3(20.0f,20.0f,20.0f),200.0f });
		meteoArray.push_back({ XMFLOAT3(260.0f,240.0f,0.0f),XMFLOAT3(26.5f,26.5f,26.5f),180.0f });
		meteoArray.push_back({ XMFLOAT3(428.0f,285.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),220.0f });
		meteoArray.push_back({ XMFLOAT3(470.0f,-225.0f,0.0f),XMFLOAT3(16.0f,16.0f,16.0f),255.0f });
		break;
case 5:
		meteoArray.push_back({ XMFLOAT3(-12000.0f,80.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),200.0f });
		meteoArray.push_back({ XMFLOAT3(-12000.0f,80.0f,0.0f),XMFLOAT3(13.5f,13.5f,13.5f),200.0f });
	default:
		break;
	}
	//イテレーター
	std::vector<TMeteo>::iterator it;
	it = meteoArray.begin();	//イテレーターを動的配列の最初に持ってくる
	while (it != meteoArray.end())
	{
		it->m_RotDir = rand() % 3;
		it++;
	}
}
